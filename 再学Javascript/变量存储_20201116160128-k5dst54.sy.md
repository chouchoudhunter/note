## 前言
{: id="20201116160137-mouyuux"}

这次的 `why what or how` 主题：`JavaScript` 变量存储。
{: id="20201116160137-0psk0yg"}

无论那门语言，变量是组成一切的基础，一个数字是一个变量，一个对象也是一个变量，在 `JavaScript` 中甚至连一个函数都是一个变量。
{: id="20201116160137-pttbv7r"}

那么如此重要的变量，在 `JavaScript` 中究竟是如何进行存储的？
{: id="20201116160137-8oizn5w"}

## 栈 & 堆 ?
{: id="20201116160137-hkrdkbv"}

> 栈（`Stack`）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。
> {: id="20201116160137-k5jllqt"}
{: id="20201116160137-5yqt9wf"}

在百度上搜索 `JavaScript` 变量存储，能看到很多文章，无外乎一个结论：
{: id="20201116160137-pcc6akv"}

> 对于原始类型，数据本身是存在栈内，对于对象类型，在栈中存的只是一个堆内地址的引用。
> {: id="20201116160137-jk6tyjt"}
{: id="20201116160137-dqhtwja"}

但是，我突然想到一个问题：如果说原始类型存在在栈中，那么 `JavaScript` 中的闭包是如何实现的？
{: id="20201116160137-qr0xnc6"}

当然想要深究这个问题，有必要先把栈（`Stack`）和堆（`Heap`）给说说清楚。
{: id="20201116160137-j8y1mri"}

那好，先说说栈。
{: id="20201116160137-y5sexq9"}

## 栈
{: id="20201116160137-7uuc855"}

栈是内存中一块用于存储局部变量和函数参数的线性结构，遵循着先进后出的原则。数据只能顺序的入栈，顺序的出栈。当然，栈只是内存中一片连续区域一种形式化的描述，数据入栈和出栈的操作仅仅是栈指针在内存地址上的上下移动而已。如下图所示（以 C 语言为例）：
{: id="20201116160137-gx5xgwv"}

![变量在栈中存储](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe8d6637150?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-t619mis"}

如图所示，栈指针刚开始指向内存中 `0x001` 的位置，接着 `sum` 函数开始调用，由于声明了两个变量，往栈中存放了两个数值，栈指针也对应开始移动，当 `sum` 函数调用结束时，仅仅是把栈指针往下移动而已，并不是真正的数据弹出，数据还在，只不过下次赋值时会被覆盖。
{: id="20201116160137-u5ge4lw"}

挺简单的不是么，但需要注明一点的是：内存中栈区的数据，在函数调用结束后，就会自动的出栈，不需要程序进行操作，操作系统会自动执行，换句话说：栈中的变量在函数调用结束后，就会消失。
{: id="20201116160137-2tg4623"}

因此栈的特点：轻量，不需要手动管理，函数调时创建，调用结束则消失。
{: id="20201116160137-mt1jadc"}

## 堆
{: id="20201116160137-5fqoyqw"}

堆可以简单的认为是一大块内存空间，就像一个篮子，你往里面放什么都没关系，但是篮子是私人物品，操作系统并不会管你的篮子里都放了什么，也不会主动去清理你的篮子，因此在 `C` 语言中，堆中内容是需要程序员手动清理的，不然就会出现内存溢出的情况。
{: id="20201116160137-snz0wmo"}

为了一定程度的解决堆的问题，一些高级语言（如 `JAVA`）提出了一个概念：`GC`，`Garbage Collection`，垃圾回收，用于协助程序管理内存，主动清理堆中已不被使用的数据。
{: id="20201116160137-k246b2r"}

既然堆是一个大大的篮子，那么在栈中存储不了的数据（比如一个对象），就会被存储在堆中，栈中就仅仅保留一个对该数据的引用（也就是该块数据的首地址）。
{: id="20201116160137-6o9tshb"}

## 问题！
{: id="20201116160137-fnx2rn0"}

`OK` 栈和堆内容如上，现在我们再来看看大家的结论：
{: id="20201116160137-wxs4enz"}

> 对于原始类型，数据本身是存在栈内，对于对象类型，在栈中存的只是一个堆内地址的引用。
> {: id="20201116160137-l8cu0oz"}
{: id="20201116160137-2gs6z24"}

感觉很符合逻辑啊，按照定义基础类型存在栈中，对象存在堆中，没毛病啊！
{: id="20201116160137-oklkhlv"}

但是，请大家思考一个问题：
{: id="20201116160137-dvemdvx"}

既然栈中数据在函数执行结束后就会被销毁，那么 `JavaScript` 中函数闭包该如何实现，先简单来个闭包：
{: id="20201116160137-k1wfnq9"}

```
function count () {
    let num = -1;
    return function () {
        num++;
        return num;
    }
}

let numCount = count();
numCount();
// 0
numCount();
// 1
复制代码
```
{: id="20201116160137-srqle10"}

按照结论，`num` 变量在调用 `count` 函数时创建，在 `return` 时从栈中弹出。
{: id="20201116160137-wkvvecz"}

既然是这样的逻辑，那么调用 `numCount` 函数如何得出 `0` 呢？`num` 在函数 `return` 时已经在内存中被销毁了啊！
{: id="20201116160137-pxgr565"}

因此，在本例中 `JavaScript` 的基础类型并不保存在栈中，而应该保存在堆中，供 `numCount` 函数使用。
{: id="20201116160137-woy48p4"}

那么网上大家的结论就是错的了？非也！接下来谈谈我对 `JavaScript` 变量存储的理解。
{: id="20201116160137-7i8lwkc"}

## 抛开栈
{: id="20201116160137-t2py7tp"}

既然在 `JavaScript` 中有闭包的问题，抛开栈（`Stack`），仅用堆能否实现变量存储？我们来看一个特殊的例子：
{: id="20201116160137-3ery6xc"}

```
function test () {
    let num = 1;
    let string = 'string';
    let bool = true;
    let obj = {
        attr1: 1,
        attr2: 'string',
        attr3: true,
        attr4: 'other'
    }
    return function log() {
        console.log(num, string, bool, obj);
    }
}
复制代码
```
{: id="20201116160137-vxw0x83"}

伴随着 `test` 的调用，为了保证变量不被销毁，在堆中先生成一个对象就叫 `Scope` 吧，把变量作为 `Scope` 的属性给存起来。堆中的数据结构大致如下所示：
{: id="20201116160137-wcfpc7v"}

![使用 Scope 保存变量](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe8d94e1d84?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-1i5v6l6"}

那么，这样就能解决闭包的问题了吗？
{: id="20201116160137-vegoufc"}

当然可以，由于 `Scope` 对象是存储在堆中，因此返回的 `log` 函数完全可以拥有 `Scope` 对象 的访问。下图是该段代码在 `Chrome` 中的执行效果：
{: id="20201116160137-x5u5q8k"}

![Chrome 中 Scope 的表示](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe8d64f7c7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-foz12pj"}

红框部分，与上述一致，同时也反应出了之前提及的问题：例子中 `JavaScript` 的变量并没有存在栈中，而是在堆里，用一个特殊的对象（`Scope`）保存。
{: id="20201116160137-zsjcrkb"}

那么在 `JavaScript` 变量到底是如何进程存储的？这和变量的类型直接挂钩，接下来就谈谈在 `JavaScript` 中变量的类型。
{: id="20201116160137-gkc4e64"}

## 三种类型
{: id="20201116160137-wma7gtl"}

在 `JavaScript` 中，变量分为三种类型：
{: id="20201116160137-eu3kqb9"}

1. {: id="20201116160137-hr154pm"}局部变量
2. {: id="20201116160137-1ye5qss"}被捕获变量
3. {: id="20201116160137-auwo7hv"}全局变量
{: id="20201116160137-ioccnql"}

### 局部变量
{: id="20201116160137-kqsi8fz"}

局部变量很好理解：在函数中声明，且在函数返回后不会被其他作用域所使用的对象。下面代码中的 `local*` 都是局部变量。
{: id="20201116160137-bz5rfp0"}

```
function test () {
    let local1 = 1;
    var local2 = 'str';
    const local3 = true;
    let local4 = {a: 1};
    return;
}
复制代码
```
{: id="20201116160137-etit4pq"}

### 被捕获变量
{: id="20201116160137-wtrycor"}

被捕获变量就是局部变量的反面：在函数中声明，但在函数返回后仍有未执行作用域（函数或是类）使用到该变量，那么该变量就是被捕获变量。下面代码中的 `catch*` 都是被捕获变量。
{: id="20201116160137-ojj043r"}

```
function test1 () {
    let catch1 = 1;
    var catch2 = 'str';
    const catch3 = true;
    let catch4 = {a: 1};
    return function () {
        console.log(catch1, catch2, catch3, catch4)
    }
}

function test2 () {
    let catch1 = 1;
    let catch2 = 'str';
    let catch3 = true;
    var catch4 = {a: 1};
    return class {
        constructor(){
            console.log(catch1, catch2, catch3, catch4)
        }
    }
}

console.dir(test1())
console.dir(test2())
复制代码
```
{: id="20201116160137-e8kvels"}

复制代码到 `Chrome` 即可查看输出对象下的 `[[Scopes]]` 下有对应的 `Scope`。
{: id="20201116160137-enszelj"}

### 全局变量
{: id="20201116160137-lbf73m4"}

全局变量就是 `global`，在 浏览器上为 `window` 在 `node` 里为 `global`。全局变量会被默认添加到函数作用域链的最低端，也就是上述函数中 `[[Scopes]]` 中的最后一个。
{: id="20201116160137-377ynjw"}

全局变量需要特别注意一点：`var` 和 `let/const` 的区别。
{: id="20201116160137-k2wsle7"}

#### var
{: id="20201116160137-8wqdhvz"}

全局的 `var` 变量其实仅仅是为 `global` 对象添加了一条属性。
{: id="20201116160137-6s20fx2"}

```
var testVar = 1;

// 与下述代码一致
windows.testVar = 1;
复制代码
```
{: id="20201116160137-9mbzfob"}

#### let / const
{: id="20201116160137-0v48qr3"}

全局的 `let/const` 变量不会修改 `windows` 对象，而是将变量的声明放在了一个特殊的对象下（与 `Scope` 类似）。
{: id="20201116160137-bq5077n"}

```
let testLet = 1;

console.dir(() => {})
复制代码
```
{: id="20201116160137-4r5f7bo"}

复制到 `Chrome` 有以下结果：
{: id="20201116160137-c4aflhk"}

![let/const 全局变量](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe8f469bd20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-s57laeg"}

## 两种方式
{: id="20201116160137-zphjh2n"}

那么变量的类型确定了，如何进行存储呢？有两种：
{: id="20201116160137-8x94hoo"}

1. {: id="20201116160137-r5xl4xl"}栈（`Stack`）
2. {: id="20201116160137-11y9qqc"}堆（`Heap`）
{: id="20201116160137-4ztfm2z"}

相信看到这里，大家心里应该都清楚了：除了局部变量，其他的全都存在堆中！根据变量的数据类型，分为以下两种情况：
{: id="20201116160137-cwk9clm"}

1. {: id="20201116160137-wp1svc3"}如果是基础类型，那栈中存的是数据本身。
2. {: id="20201116160137-axed21n"}如果是对象类型，那栈中存的是堆中对象的引用。
{: id="20201116160137-x6c0wz1"}

但这是理想情况，再问大家一个问题：`JavaScript` 解析器如何判断一个变量是局部变量呢？
{: id="20201116160137-i8cukci"}

判断出是否被内部函数引用即可！
{: id="20201116160137-koub1az"}

那如果 `JavaScript` 解析器并没有判断呢？那就只能存在堆里！
{: id="20201116160137-si7vvt1"}

那么你一定想问，`Chrome` 的 `V8` 能否判断出，从结果看应该是可以的。
{: id="20201116160137-5qyhvu4"}

![Chrome 下的局部变量](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe8d99f3681?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-8mai7lh"}

红框内仅有变量 `a`，而变量 `b` 已经消失不见了。由于 `FireFox` 打印不出 `[[Scopes]]` 属性，因此，笔者判断不出。当然，如果有大佬能深入了解并补充的话，感激不尽。
{: id="20201116160137-xn2cjls"}

好，了解了如何存储，接下来我们看看如何赋值。
{: id="20201116160137-2hdn8xg"}

## 变量赋值
{: id="20201116160137-mfp3s6i"}

其实不论变量是存在栈内，还是存在堆里（反正都是在内存里），其结构和存值方式是差不多的，都有如下的结构：
{: id="20201116160137-bhfctif"}

![变量存储](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe8d8ab1f76?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-1wlqrg2"}

那好现在我们来看看赋值，根据 `=` 号右边变量的类型分为两种方式：
{: id="20201116160137-jp49d8r"}

### 赋值为常量
{: id="20201116160137-acx1ov9"}

何为常量？常量就是一声明就可以确定的值，比如 `1`、`"string"`、`true`、`{a: 1}`，都是常量，这些值一旦声明就不可改变，有些人可能会犟，对象类型的这么可能是常量，它可以改变啊，这个问题先留着，等下在解释。
{: id="20201116160137-8w5tu2a"}

假设现在有如下代码：
{: id="20201116160137-83g8h05"}

```
let foo = 1;
复制代码
```
{: id="20201116160137-vdyg9fl"}

`JavaScript`  声明了一个变量 `foo`，且让它的值为 `1`，内存中就会发生如下变化
{: id="20201116160137-552ec49"}

![常量储存](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe8fcf9384c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-qvjbqmn"}

如果现在又声明了一个 `bar` 变量：
{: id="20201116160137-msn5ub3"}

```
let bar = 2;
复制代码
```
{: id="20201116160137-q6hoy2h"}

那么内存中就会变成这样：
{: id="20201116160137-resafw3"}

![foo & bar](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe8ff8e00ab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-7z0wv87"}

现在回顾下刚刚的问题：对象类型算常量吗？
{: id="20201116160137-3mko0cr"}

比如有以下代码：
{: id="20201116160137-sz5och3"}

```
let obj = {
    foo: 1,
    bar: 2
}
复制代码
```
{: id="20201116160137-iwpm1wf"}

内存模型如下：
{: id="20201116160137-g2ood8m"}

![JavaScript Object存储](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe9012f8fb1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-60zzdzn"}

通过该图，我们就可以知道，其实 `obj` 指向的内存地址保存的也是一个地址值，那好，如果我们让 `obj.foo = 'foo'` 其实修改的是 `0x1021` 所在的内存区域，但 `obj` 指向的内存地址不会发生改变，因此，对象是常量！
{: id="20201116160137-yli81jm"}

### 赋值为变量
{: id="20201116160137-b05iq7u"}

何为变量？在上述过程中的 `foo`、`bar`、`obj`，都是变量，变量代表一种引用关系，其本身的值并不确定。
{: id="20201116160137-sjyw8fe"}

那么如果我将一个变量的值赋值给另一变量，会发生什么？
{: id="20201116160137-hcuypo9"}

```
let x = foo;
复制代码
```
{: id="20201116160137-alisyy1"}

![x 赋值为 foo 变量](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe909ca4c0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-nw8ri92"}

如上图所示，仅仅是将 `x` 引用到与 `foo` 一样的地址值而已，并不会使用新的内存空间。
{: id="20201116160137-87qsdo3"}

`OK` 赋值到此为止，接下来是修改。
{: id="20201116160137-qg2ztqs"}

## 变量修改
{: id="20201116160137-0dn10ir"}

与变量赋值一样，变量的修改也需要根据 `=` 号右边变量的类型分为两种方式：
{: id="20201116160137-exao10d"}

### 修改为常量
{: id="20201116160137-oxkch33"}

```
foo = 'foo';
复制代码
```
{: id="20201116160137-02ldynu"}

![foo 变量修改为另一常量](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe91f9b265a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-disa2k5"}

如上图所示，内存中保存了 `'foo'` 并将 `foo` 的引用地址修改为 `0x0204`。
{: id="20201116160137-ekgmqf8"}

### 修改为变量
{: id="20201116160137-5aze6pn"}

```
foo = bar;
复制代码
```
{: id="20201116160137-ff38qwf"}

![foo 变量修改为另一变量](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe92509edc6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-9lcd58d"}

如上图所示，仅仅是将 `foo` 引用的地址修改了而已。
{: id="20201116160137-7dds94a"}

> 有一个疑问就是foo=bar，只是把foo的引用地址改成了bar的，那岂不是修改foo的值会修改bar的值，其实不是，修改的值是常量的时候会开辟新的内存空间
> {: id="20201116160240-vgn8rfh"}
{: id="20201116160210-ex7o3pc"}

{: id="20201116160209-9nm0kn0"}

## const 的工作机制
{: id="20201116160137-crgbfvw"}

`const` 为 `ES6` 新出的变量声明的一种方式，被 `const` 修饰的变量不能改变。
{: id="20201116160137-z5qqryj"}

其实对应到 `JavaScript` 的变量储存图中，就是变量所指向的内存地址不能发生变化。也就是那个箭头不能有改变。
{: id="20201116160137-9mc21sl"}

比如说以下代码：
{: id="20201116160137-hxhqu9o"}

```
const foo = 'foo';
foo = 'bar'; // Error
复制代码
```
{: id="20201116160137-dhyh4hm"}

![const 不允许重新赋值](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe928914587?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-63pevcn"}

如上图的关系图所示，`foo` 不能引用到别的地址值。
{: id="20201116160137-vne0eh4"}

那好现在是否能解决你对下面代码的困惑：
{: id="20201116160137-y3ypks8"}

```
const obj = {
    foo: 1,
    bar: 2
};
obj.foo = 2;
复制代码
```
{: id="20201116160137-y5xzy6g"}

其 `obj` 所引用的地址并没有发生变化，发生变的部分为另一区域。如下图所示
{: id="20201116160137-y83tkhe"}

![const 对象类型修改](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe934a025ee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-li9xoo9"}

## 对象的修改
{: id="20201116160137-z6zs5bi"}

`OK` 进入一个面试时极度容易问到的问题：
{: id="20201116160137-5a11li1"}

```
let obj1 = {
    foo: 'foo',
    bar: 'bar'
}

let obj2 = obj1;
let obj3 = {
    foo: 'foo',
    bar: 'bar'
}

console.log(obj1 === obj2);
console.log(obj1 === obj3);

obj2.foo = 'foofoo';

console.log(obj1.foo === 'foofoo');
复制代码
```
{: id="20201116160137-h1b4qt6"}

请依次说出 `console` 的结果。
{: id="20201116160137-vapsec4"}

我们不讨论结果，先看看内存中的结构。
{: id="20201116160137-ttx3gi4"}

![js 中对象存储](https://user-gold-cdn.xitu.io/2019/11/15/16e6cfe92c5cd1a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201116160137-lbya5dw"}

所以你现在知道答案了吗？
{: id="20201116160137-owqjimn"}

## 总结
{: id="20201116160137-7gjixjy"}

在 `JavaScript` 中变量并非完完全全的存在在栈中，早期的 `JavaScript` 编译器甚至把所有的变量都存在一个名为闭包的对象中，`JavaScript` 是一门以函数为基础的语言，其中的函数变化无穷，因此使用栈并不能解决语言方面的问题，希望大家能看到，并真正的了解 `JavaScript` 在内存中的模型吧。
{: id="20201116160137-xqq3amc"}

作者：斑码
链接：https://juejin.im/post/6844903997615128583
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
{: id="20201116160137-f6utu4l"}
