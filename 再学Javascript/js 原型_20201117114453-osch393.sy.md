## 前言
{: id="20201117114455-a8pypx0"}

这次的 `why what or how` 主题：`JavaScript` 对象 `&` 原型。
{: id="20201117114455-z2s8yl3"}

此类文章在百度上一搜一大把，其实不用再写了，但是本着把这个问题解释的清清楚楚明明白白，还是开始写了。
{: id="20201117114455-c63ttc6"}

原因如下：
{: id="20201117114455-mc9kvl0"}

1. {: id="20201117114455-t0lotji"}面试宝典类文章，弄张图片一糊弄，让人觉得自己理解了。
2. {: id="20201117114455-7smk0fu"}解释类文章，告诉你一堆语法，对语法一顿解释，告诉你就是这样的，还是没说清楚。
3. {: id="20201117114455-yimksd6"}很少有文章单独解释这个点！但这个点是基础！真的很重要！
{: id="20201117114455-g4eib9q"}

所以本篇文章想说一说`对象 & 原型`，但为了确保能顺利理解，请先看完 [`JS 变量存储？栈 & 堆？NONONO!`](https://blog.acohome.cn/js-variable-in-memory/)，因为该篇文章从变量存储的角度来解释 `JavaScript 对象 & 原型`，请确保看完，在看这篇文章。
{: id="20201117114455-c3gkd92"}

## 什么是对象？
{: id="20201117114455-yyqr346"}

既然要说清楚，先问一个最最基本的问题：什么是对象？
{: id="20201117114455-attyyho"}

对象一句话就能解释清楚：
{: id="20201117114455-ddpzprh"}

> 对象是一系列属性 & 数据的集合。
> {: id="20201117114455-9vab0un"}
{: id="20201117114455-z91f0at"}

在 `JavaScript` 中创建一个对象的方式有很多，常见的如下：
{: id="20201117114455-iod80na"}

```
// 字面量直接创建
let obj1 = {foo: 'bar'};

// 通过实例化 Object 类
let obj2 = new Object({foo: 'bar'});

class A {
    constructor(foo){
        this.foo = foo;
    }
}

// 通过自定义类创建
let obj3 = new A('bar');
复制代码
```
{: id="20201117114455-fv1o86q"}

以上代码最终都产生了 `{foo: 'bar'}` 这个对象。对象下有一个叫 `foo` 的属性，它的值为 `bar`。那么它在堆中是如何存储的呢？
{: id="20201117114455-u5quuyc"}

![JavaScript 下对象的存储](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f391b7f82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-91ryj26"}

看过了 [`JS 变量存储？栈 & 堆？NONONO!`](https://blog.acohome.cn/js-variable-in-memory/) 相信大家对于上图应该不陌生。
{: id="20201117114455-uhaxk5k"}

## 对象的取值
{: id="20201117114455-1ktonco"}

我们继续看一个较为复杂的对象（对象下某个属性也是一个对象）：
{: id="20201117114455-56w2uxb"}

```
let complexObj = {
    num: 1,
    str: 'string',
    obj: {
        foo: 'bar',
    }
}
复制代码
```
{: id="20201117114455-ht76tif"}

在内存中的模型如下：
{: id="20201117114455-t4mez9n"}

![复杂对象模型](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f392208b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-wmqec7k"}

我们模拟一下 `complexObj.obj.foo` 这个取值过程。
{: id="20201117114455-afjqp1p"}

![复杂对象取值过程](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f39ea9b9a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-masu729"}

取值过程：碰到存储的值是地址值时，就到相应的地址值继续进行操作。
{: id="20201117114455-5r46xot"}

对象，总的来说，知识点有两点：
{: id="20201117114455-58ymr38"}

1. {: id="20201117114455-rbk15su"}创建对象：在内存堆中开辟一块用于存储一系列`属性 & 数据` 的空间。
2. {: id="20201117114455-8fx00ab"}对象取值：根据存储的数据取值，如果是地址值，则到相应内存堆中继续进行操作。
{: id="20201117114455-ojgts5u"}

对象到这里就差不多了，那原型又是什么呢？
{: id="20201117114455-aooowtj"}

## 原型 & 原型链
{: id="20201117114455-z2z50p9"}

> 原型是对象下的一个属性，每个对象都有，同时原型也是一个对象。
> {: id="20201117114455-i5g36u2"}
{: id="20201117114455-ncnnlcf"}

文本的描述总是不直观的，我们通过代码来看：
{: id="20201117114455-qpslswv"}

```
let proto = {
    foo: 'bar'
}

let obj = {
    // ...
    __proto__: proto
}
复制代码
```
{: id="20201117114455-g2c4zgn"}

设置对象 `__proto__` 属性的过程，就是给对象设置了原型，同时该属性指向一个对象。
{: id="20201117114455-u1xhriq"}

**注：** 当然 `ES6` 已经不建议这么做了，有专门的方法（`setPrototypeOf`）设置原型，为了解释方便，这里用 `ES5` 的代码作为示例。
{: id="20201117114455-sytj4aa"}

有人可能会有疑问：既然是赋值操作，那应该也可以给对象的原型设置为非对象，为什么原型是对象呢？关于这个问题的答案，可以用以下代码测试：
{: id="20201117114455-t7804w6"}

```
let a = {};
a.__proto__ = 1;
console.log(a.__proto__);
复制代码
```
{: id="20201117114455-ze62hq3"}

复制到浏览器即可看到效果，将对象的原型设置为非对象这个操作，是被禁止的，也就是说你设置了也没用。
{: id="20201117114455-1mrtlxp"}

原型的定义也很简单，那么原型是干嘛用的呢？
{: id="20201117114455-u9r6r6i"}

## 原型的作用
{: id="20201117114455-4320rl3"}

> 原型补充了原对象，当需要访问对象中属性，但该属性又不存在时，就会去原型上寻找。
> {: id="20201117114455-8k4uqkq"}
{: id="20201117114455-iuh6o03"}

按照上面的例子，`obj.foo` 返回什么？以下伪代码就是寻值的过程：
{: id="20201117114455-wo3hme8"}

```
function getValue(obj, attr){
    let searchObj = obj
    while(searchObj 下不存在 attr 属性){
        searchObj = obj 的原型
    }
    return searchObj 下的 attr 属性 
}

getValue(obj, 'foo')
复制代码
```
{: id="20201117114455-q52arx8"}

以下为图示过程：
{: id="20201117114455-x3fg9pc"}

![获取原型上的属性](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f4eb58ba5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-04hmedm"}

根据上图（或是伪代码）我们可得知最终的结果是： `bar`。
{: id="20201117114455-6dl9gmi"}

那如果对象上的原型还是没有该属性呢？
{: id="20201117114455-cpnayzc"}

在原型的定义中，提到过：原型同时也是一个对象。转换一下思路，那么这个问题就变成了：如果对象上没有该属性那会发生什么？
{: id="20201117114455-5q0vify"}

去对象下的原型下找！对！我们刚说完！
{: id="20201117114455-dlcpv60"}

这种层层递进的关系我们就把它称为：原型链！
{: id="20201117114455-uikho4l"}

到这你可能会问：如果按照这样一直找下去，那不是无穷无尽了？这就需要引出一个特殊的对象，可以在 `Chrome` 的控制台打印 `Object.prototype` 输出的对象，你可以仔细找找，该对象有没有原型？
{: id="20201117114455-pl8g8wk"}

`OH NO!` 竟然有原型，你个骗子。
{: id="20201117114455-7hdy4p4"}

不要激动，继续去查看它原型是什么：`null`！
{: id="20201117114455-nu778lh"}

这和我之前说的：原型也是一个对象，有出入，因为 `null` 明显不是一个对象。
{: id="20201117114455-w148jmh"}

但是，`typeof null` 确实是 `object`，笔者也有猜想过是不是和这有关系。但猜想是猜想，为了语义的完整性，我们重新定义一下原型：
{: id="20201117114455-ymuskjy"}

> 原型是对象下的一个属性，每个对象都有，同时原型是对象或是 `null`。
> {: id="20201117114455-m4p8v6p"}
{: id="20201117114455-bq9p5m2"}

同时定义一下原型链的特点：
{: id="20201117114455-4gdfra7"}

> 原型链由一个个对象组成，原型链有终点，这个终点是 `null`。
> {: id="20201117114455-u1s1pal"}
{: id="20201117114455-6jzcras"}

`OK` 既然原型链有了终点，那么如果一个属性在原对象和所有的原型链上都不存在的话，他的值是什么？
{: id="20201117114455-1qe3z0f"}

`undefined`（未定义）啊！
{: id="20201117114455-odhifa0"}

现在我们已经清楚原型和对象的关系，那如何设置对象的原型呢？
{: id="20201117114455-0o8tin1"}

## 设置原型
{: id="20201117114455-k7nwz03"}

其实上面已经提到过，我们可以直接设置对象的原型：
{: id="20201117114455-7cgc6sc"}

### ES5 中
{: id="20201117114455-qgni8m8"}

```
let proto = {
    foo: 'bar'
}

let obj = {
    // ...
    __proto__: proto
}
复制代码
```
{: id="20201117114455-aaacs0x"}

### ES6 中
{: id="20201117114455-x8wmtf6"}

由于 `__proto__` 是非标准属性，因此在 `ES6` 中建议使用 `setPrototypeOf` 设置对象的原型。
{: id="20201117114455-l1sjg23"}

```
let obj = {};

let proto = {
    foo: 'bar'
}

Object.setPrototypeOf(obj, proto);
复制代码
```
{: id="20201117114455-kvu4yl1"}

那如果一个对象还没有生成，比如仅仅定义了一个类，但又想控制通过这个类生成的对象的原型，该如何呢？
{: id="20201117114455-3j8r4p5"}

既然问了，那肯定是有的，解决方案就是函数的 `prototype` 属性。
{: id="20201117114455-8b3xy84"}

## prototype
{: id="20201117114455-4tsxgdy"}

我们都知道在 `JavaScript` 中函数也是一个对象，这个特殊对象下有一个 `prototype` 属性，是干嘛用的呢？
{: id="20201117114455-1xzht9e"}

> 在使用 `new` 关键字调用该函数时，函数下的 `prototype` 属性所保存的对象就是生成对象的原型。
> {: id="20201117114455-etna4hc"}
{: id="20201117114455-ur8vq8w"}

通过代码来解释：
{: id="20201117114455-qp8hzgn"}

```
function A(bar) {
    this.bar = bar;
}

A.prototype.test = function(){
    console.log('test');
}
A.prototype.testAttr = 'testAttr';

let a = new A('bar');
复制代码
```
{: id="20201117114455-zsnyjvs"}

下面用伪代码来解释 `new A('bar')` 这个过程：
{: id="20201117114455-wej8qvz"}

```
function fakeNew(A, bar){
    // 生成 this 为一个空对象。
    let this = {};
    Object.setPrototypeOf(this, A.prototype);
  
    // 执行 A 函数内的代码
    this.foo = bar;
  
    // 将 this 返回
    return this;
}

fakeNew(A, 'bar');
复制代码
```
{: id="20201117114455-2o9zsx1"}

相信大家看完代码就能理解 `prototype` 这个属性的作用了，但这是 `ES5` 的代码，`ES6` 中并不建议直接写 `prototype` ，而直接使用 `class`，但其本质是一样的。复制下面代码到 `Chrome` 里即可查到真相：
{: id="20201117114455-nelivvq"}

```
class A {
    constructor(bar) {
        this.foo = bar;
    }
    test() {
        console.log('test');
    }
}

console.dir(A);
复制代码
```
{: id="20201117114455-nti4qd6"}

![class 的 prototype](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f39abc3bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-trujzvl"}

如上图所示，`A` 仍有 `prototype` 属性，并且定义中除了 `constructor` 函数，其他的函数都在 `prototype` 属性内。
{: id="20201117114455-j25d7fj"}

可以认为是 `ES5 function` 语法糖吧，至少这里可以这么认为，但请不要认定，相比较于 `ES5 function` 还是有差别的，这块内容不属于本篇范畴，有机会单独写一篇讨论讨论。
{: id="20201117114455-zclrcfl"}

## 对象的创建
{: id="20201117114455-cfo1pm7"}

绕了一圈，又绕了回来，现在我们回过头来看看对象的创建。
{: id="20201117114455-9f1bey4"}

通过以上的阐述，我们知道了以下几点：
{: id="20201117114455-p0vf3kz"}

1. {: id="20201117114455-hw6j4zu"}对象是一些列`属性 & 数据` 的集合。
2. {: id="20201117114455-erwdcd9"}原型是对象下的一个属性，它的值是一个对象（或`null`）。
{: id="20201117114455-n8an8ta"}

那好，现在我在问一个问题，你用以下代码创建的对象，它的原型是什么？
{: id="20201117114455-kb1i420"}

```
let obj = {};
复制代码
```
{: id="20201117114455-gp8wypl"}

有点疑惑？因为它既没有主动添加原型，也不是从类创建的对象，那他的原型就没有了？
{: id="20201117114455-us99rod"}

答案当然是否定的，只要你把这段代码贴到 `Chrome` 控制台就可以了。想要进一步知道这个对象到底哪儿来的，试试以下代码：
{: id="20201117114455-2bg6523"}

```
obj.__proto__ === Object.prototype; // true
复制代码
```
{: id="20201117114455-35w8ofj"}

很明显，这个新创建的对象为 `Object` 这个类的 `prototype` 属性，难不成这个 `obj` 是通过 `Object` 类创建的？
{: id="20201117114455-ou4t8ft"}

`bingo ~` 你离真相又进了一步，在 `JavaScript` 中所有的对象都由 `Object` 所创建（PS：不管你用什么姿势！）。
{: id="20201117114455-xyy9ouo"}

好，对象的直接创建弄明白了，在来个间接创建的问题，请问以下代码所创建的 `obj` 的原型是什么？
{: id="20201117114455-r2t5rpt"}

```
function A (){};
let obj = new A();
复制代码
```
{: id="20201117114455-ienwv12"}

当然是 `A` 的 `prototype` 啊，这还用问？那 `A` 的 `prototype` 又是什么呢？
{: id="20201117114455-41su61b"}

放到 `Chrome` 下一看便知：
{: id="20201117114455-kjmwdyx"}

![function 的 prototype](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f4ed909b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-nf7k173"}

由上图可见，是一个简单的对象，最原始的 `prototype` 其中仅仅包含了 `constructor` 和 `__proto__`。
{: id="20201117114455-4og0br7"}

`constructor` 就是引用它自己。
{: id="20201117114455-iltil9l"}

```
A.prototype.constructor === A; // true
复制代码
```
{: id="20201117114455-6udaih3"}

`__proto__` 就是这个对象的原型，只要是一个对象，自然而然会有这个属性，那么这个属性的值是什么？
{: id="20201117114455-74reo77"}

```
A.prototype.__proto__ === Object.prototype; // true
复制代码
```
{: id="20201117114455-kmqswd0"}

当然是 `Object.prototype` 啊，所有对象都由 `Object` 这个类所创建嘛！
{: id="20201117114455-erxzygz"}

作者：斑码
链接：https://juejin.im/post/6844904016367845389
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
{: id="20201117114455-rbpkiju"}

## 前言
{: id="20201117114455-olbu0y4"}

这次的 `why what or how` 主题：`JavaScript` 对象 `&` 原型。
{: id="20201117114455-jpdpkvu"}

此类文章在百度上一搜一大把，其实不用再写了，但是本着把这个问题解释的清清楚楚明明白白，还是开始写了。
{: id="20201117114455-4i0j4oj"}

原因如下：
{: id="20201117114455-m1kjrs8"}

1. {: id="20201117114455-4yzmlhs"}面试宝典类文章，弄张图片一糊弄，让人觉得自己理解了。
2. {: id="20201117114455-a1j6buv"}解释类文章，告诉你一堆语法，对语法一顿解释，告诉你就是这样的，还是没说清楚。
3. {: id="20201117114455-m3skrd4"}很少有文章单独解释这个点！但这个点是基础！真的很重要！
{: id="20201117114455-f61vch7"}

所以本篇文章想说一说`对象 & 原型`，但为了确保能顺利理解，请先看完 [`JS 变量存储？栈 & 堆？NONONO!`](https://blog.acohome.cn/js-variable-in-memory/)，因为该篇文章从变量存储的角度来解释 `JavaScript 对象 & 原型`，请确保看完，在看这篇文章。
{: id="20201117114455-7y56v1p"}

## 什么是对象？
{: id="20201117114455-vbcugnb"}

既然要说清楚，先问一个最最基本的问题：什么是对象？
{: id="20201117114455-xvwusz0"}

对象一句话就能解释清楚：
{: id="20201117114455-9s6xdg1"}

> 对象是一系列属性 & 数据的集合。
> {: id="20201117114455-ccp6di9"}
{: id="20201117114455-i6imo7o"}

在 `JavaScript` 中创建一个对象的方式有很多，常见的如下：
{: id="20201117114455-itrd5wo"}

```
// 字面量直接创建
let obj1 = {foo: 'bar'};

// 通过实例化 Object 类
let obj2 = new Object({foo: 'bar'});

class A {
    constructor(foo){
        this.foo = foo;
    }
}

// 通过自定义类创建
let obj3 = new A('bar');
复制代码
```
{: id="20201117114455-bjynivp"}

以上代码最终都产生了 `{foo: 'bar'}` 这个对象。对象下有一个叫 `foo` 的属性，它的值为 `bar`。那么它在堆中是如何存储的呢？
{: id="20201117114455-m7t0r12"}

![JavaScript 下对象的存储](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f391b7f82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-qy0ynsu"}

看过了 [`JS 变量存储？栈 & 堆？NONONO!`](https://blog.acohome.cn/js-variable-in-memory/) 相信大家对于上图应该不陌生。
{: id="20201117114455-3hczal4"}

## 对象的取值
{: id="20201117114455-5rg2zrt"}

我们继续看一个较为复杂的对象（对象下某个属性也是一个对象）：
{: id="20201117114455-wslb7xk"}

```
let complexObj = {
    num: 1,
    str: 'string',
    obj: {
        foo: 'bar',
    }
}
复制代码
```
{: id="20201117114455-t75eszv"}

在内存中的模型如下：
{: id="20201117114455-7qq6zgh"}

![复杂对象模型](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f392208b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-86sjzqz"}

我们模拟一下 `complexObj.obj.foo` 这个取值过程。
{: id="20201117114455-5or7in0"}

![复杂对象取值过程](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f39ea9b9a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-1jyb5un"}

取值过程：碰到存储的值是地址值时，就到相应的地址值继续进行操作。
{: id="20201117114455-1z76doi"}

对象，总的来说，知识点有两点：
{: id="20201117114455-uybokmq"}

1. {: id="20201117114455-j4ctjkh"}创建对象：在内存堆中开辟一块用于存储一系列`属性 & 数据` 的空间。
2. {: id="20201117114455-ezvvgk7"}对象取值：根据存储的数据取值，如果是地址值，则到相应内存堆中继续进行操作。
{: id="20201117114455-nxy95o0"}

对象到这里就差不多了，那原型又是什么呢？
{: id="20201117114455-a0bqgdd"}

## 原型 & 原型链
{: id="20201117114455-w79f7sy"}

> 原型是对象下的一个属性，每个对象都有，同时原型也是一个对象。
> {: id="20201117114455-y1npja3"}
{: id="20201117114455-2tmt84h"}

文本的描述总是不直观的，我们通过代码来看：
{: id="20201117114455-f0b199p"}

```
let proto = {
    foo: 'bar'
}

let obj = {
    // ...
    __proto__: proto
}
复制代码
```
{: id="20201117114455-dub2qfi"}

设置对象 `__proto__` 属性的过程，就是给对象设置了原型，同时该属性指向一个对象。
{: id="20201117114455-9oemaom"}

**注：** 当然 `ES6` 已经不建议这么做了，有专门的方法（`setPrototypeOf`）设置原型，为了解释方便，这里用 `ES5` 的代码作为示例。
{: id="20201117114455-b62wtnf"}

有人可能会有疑问：既然是赋值操作，那应该也可以给对象的原型设置为非对象，为什么原型是对象呢？关于这个问题的答案，可以用以下代码测试：
{: id="20201117114455-2up7zek"}

```
let a = {};
a.__proto__ = 1;
console.log(a.__proto__);
复制代码
```
{: id="20201117114455-krvw7js"}

复制到浏览器即可看到效果，将对象的原型设置为非对象这个操作，是被禁止的，也就是说你设置了也没用。
{: id="20201117114455-6vj410a"}

原型的定义也很简单，那么原型是干嘛用的呢？
{: id="20201117114455-5bqrki9"}

## 原型的作用
{: id="20201117114455-fh6mjrx"}

> 原型补充了原对象，当需要访问对象中属性，但该属性又不存在时，就会去原型上寻找。
> {: id="20201117114455-k584mpf"}
{: id="20201117114455-if9hxwa"}

按照上面的例子，`obj.foo` 返回什么？以下伪代码就是寻值的过程：
{: id="20201117114455-56z3wk8"}

```
function getValue(obj, attr){
    let searchObj = obj
    while(searchObj 下不存在 attr 属性){
        searchObj = obj 的原型
    }
    return searchObj 下的 attr 属性 
}

getValue(obj, 'foo')
复制代码
```
{: id="20201117114455-wm4mgln"}

以下为图示过程：
{: id="20201117114455-ucts2sv"}

![获取原型上的属性](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f4eb58ba5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-ac72avv"}

根据上图（或是伪代码）我们可得知最终的结果是： `bar`。
{: id="20201117114455-ozckrmz"}

那如果对象上的原型还是没有该属性呢？
{: id="20201117114455-wb7o6a9"}

在原型的定义中，提到过：原型同时也是一个对象。转换一下思路，那么这个问题就变成了：如果对象上没有该属性那会发生什么？
{: id="20201117114455-2a67jb3"}

去对象下的原型下找！对！我们刚说完！
{: id="20201117114455-xyp0w98"}

这种层层递进的关系我们就把它称为：原型链！
{: id="20201117114455-38kpzp9"}

到这你可能会问：如果按照这样一直找下去，那不是无穷无尽了？这就需要引出一个特殊的对象，可以在 `Chrome` 的控制台打印 `Object.prototype` 输出的对象，你可以仔细找找，该对象有没有原型？
{: id="20201117114455-vha4400"}

`OH NO!` 竟然有原型，你个骗子。
{: id="20201117114455-r7qzz13"}

不要激动，继续去查看它原型是什么：`null`！
{: id="20201117114455-ylpkzr7"}

这和我之前说的：原型也是一个对象，有出入，因为 `null` 明显不是一个对象。
{: id="20201117114455-xpz7raz"}

但是，`typeof null` 确实是 `object`，笔者也有猜想过是不是和这有关系。但猜想是猜想，为了语义的完整性，我们重新定义一下原型：
{: id="20201117114455-bj0n5dq"}

> 原型是对象下的一个属性，每个对象都有，同时原型是对象或是 `null`。
> {: id="20201117114455-tbzg4tg"}
{: id="20201117114455-k8qinul"}

同时定义一下原型链的特点：
{: id="20201117114455-9zr20y2"}

> 原型链由一个个对象组成，原型链有终点，这个终点是 `null`。
> {: id="20201117114455-omhu455"}
{: id="20201117114455-2y2d37x"}

`OK` 既然原型链有了终点，那么如果一个属性在原对象和所有的原型链上都不存在的话，他的值是什么？
{: id="20201117114455-8nhykax"}

`undefined`（未定义）啊！
{: id="20201117114455-skz3bm8"}

现在我们已经清楚原型和对象的关系，那如何设置对象的原型呢？
{: id="20201117114455-ndfn8h2"}

## 设置原型
{: id="20201117114455-qg7mddd"}

其实上面已经提到过，我们可以直接设置对象的原型：
{: id="20201117114455-1y9g6z7"}

### ES5 中
{: id="20201117114455-kz9wz1h"}

```
let proto = {
    foo: 'bar'
}

let obj = {
    // ...
    __proto__: proto
}
复制代码
```
{: id="20201117114455-0m3glp7"}

### ES6 中
{: id="20201117114455-14k97tm"}

由于 `__proto__` 是非标准属性，因此在 `ES6` 中建议使用 `setPrototypeOf` 设置对象的原型。
{: id="20201117114455-r3owc4a"}

```
let obj = {};

let proto = {
    foo: 'bar'
}

Object.setPrototypeOf(obj, proto);
复制代码
```
{: id="20201117114455-dl79qzy"}

那如果一个对象还没有生成，比如仅仅定义了一个类，但又想控制通过这个类生成的对象的原型，该如何呢？
{: id="20201117114455-5wequ8n"}

既然问了，那肯定是有的，解决方案就是函数的 `prototype` 属性。
{: id="20201117114455-nelzkj0"}

## prototype
{: id="20201117114455-ixkurw7"}

我们都知道在 `JavaScript` 中函数也是一个对象，这个特殊对象下有一个 `prototype` 属性，是干嘛用的呢？
{: id="20201117114455-mjgnqb5"}

> 在使用 `new` 关键字调用该函数时，函数下的 `prototype` 属性所保存的对象就是生成对象的原型。
> {: id="20201117114455-ozy2ea3"}
{: id="20201117114455-or4kgw3"}

通过代码来解释：
{: id="20201117114455-2tdvb27"}

```
function A(bar) {
    this.bar = bar;
}

A.prototype.test = function(){
    console.log('test');
}
A.prototype.testAttr = 'testAttr';

let a = new A('bar');
复制代码
```
{: id="20201117114455-j6v8p8z"}

下面用伪代码来解释 `new A('bar')` 这个过程：
{: id="20201117114455-x6iriha"}

```
function fakeNew(A, bar){
    // 生成 this 为一个空对象。
    let this = {};
    Object.setPrototypeOf(this, A.prototype);
  
    // 执行 A 函数内的代码
    this.foo = bar;
  
    // 将 this 返回
    return this;
}

fakeNew(A, 'bar');
复制代码
```
{: id="20201117114455-c4x0xa6"}

相信大家看完代码就能理解 `prototype` 这个属性的作用了，但这是 `ES5` 的代码，`ES6` 中并不建议直接写 `prototype` ，而直接使用 `class`，但其本质是一样的。复制下面代码到 `Chrome` 里即可查到真相：
{: id="20201117114455-zs6l6f2"}

```
class A {
    constructor(bar) {
        this.foo = bar;
    }
    test() {
        console.log('test');
    }
}

console.dir(A);
复制代码
```
{: id="20201117114455-sq6if0z"}

![class 的 prototype](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f39abc3bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-cxzhd1b"}

如上图所示，`A` 仍有 `prototype` 属性，并且定义中除了 `constructor` 函数，其他的函数都在 `prototype` 属性内。
{: id="20201117114455-ushoaqk"}

可以认为是 `ES5 function` 语法糖吧，至少这里可以这么认为，但请不要认定，相比较于 `ES5 function` 还是有差别的，这块内容不属于本篇范畴，有机会单独写一篇讨论讨论。
{: id="20201117114455-e96ygfr"}

## 对象的创建
{: id="20201117114455-mkonkv6"}

绕了一圈，又绕了回来，现在我们回过头来看看对象的创建。
{: id="20201117114455-ab8fhlr"}

通过以上的阐述，我们知道了以下几点：
{: id="20201117114455-na1ovq0"}

1. {: id="20201117114455-us7oexp"}对象是一些列`属性 & 数据` 的集合。
2. {: id="20201117114455-mjsqvnk"}原型是对象下的一个属性，它的值是一个对象（或`null`）。
{: id="20201117114455-c42ql12"}

那好，现在我在问一个问题，你用以下代码创建的对象，它的原型是什么？
{: id="20201117114455-g5vy1e8"}

```
let obj = {};
复制代码
```
{: id="20201117114455-zaycxph"}

有点疑惑？因为它既没有主动添加原型，也不是从类创建的对象，那他的原型就没有了？
{: id="20201117114455-o7jac22"}

答案当然是否定的，只要你把这段代码贴到 `Chrome` 控制台就可以了。想要进一步知道这个对象到底哪儿来的，试试以下代码：
{: id="20201117114455-914whc4"}

```
obj.__proto__ === Object.prototype; // true
复制代码
```
{: id="20201117114455-o7jp4hf"}

很明显，这个新创建的对象为 `Object` 这个类的 `prototype` 属性，难不成这个 `obj` 是通过 `Object` 类创建的？
{: id="20201117114455-62m5uzb"}

`bingo ~` 你离真相又进了一步，在 `JavaScript` 中所有的对象都由 `Object` 所创建（PS：不管你用什么姿势！）。
{: id="20201117114455-7sayjkv"}

好，对象的直接创建弄明白了，在来个间接创建的问题，请问以下代码所创建的 `obj` 的原型是什么？
{: id="20201117114455-ote2dlt"}

```
function A (){};
let obj = new A();
复制代码
```
{: id="20201117114455-frvgkjl"}

当然是 `A` 的 `prototype` 啊，这还用问？那 `A` 的 `prototype` 又是什么呢？
{: id="20201117114455-bpgv6y6"}

放到 `Chrome` 下一看便知：
{: id="20201117114455-95ll8kk"}

![function 的 prototype](https://user-gold-cdn.xitu.io/2019/12/9/16ee850f4ed909b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
{: id="20201117114455-1y5p4xr"}

由上图可见，是一个简单的对象，最原始的 `prototype` 其中仅仅包含了 `constructor` 和 `__proto__`。
{: id="20201117114455-wis5rw4"}

`constructor` 就是引用它自己。
{: id="20201117114455-gvei7gt"}

```
A.prototype.constructor === A; // true
复制代码
```
{: id="20201117114455-zwtwrkl"}

`__proto__` 就是这个对象的原型，只要是一个对象，自然而然会有这个属性，那么这个属性的值是什么？
{: id="20201117114455-j2s2x0b"}

```
A.prototype.__proto__ === Object.prototype; // true
复制代码
```
{: id="20201117114455-vkkhpcf"}

当然是 `Object.prototype` 啊，所有对象都由 `Object` 这个类所创建嘛！
{: id="20201117114455-ahrny0m"}

{: id="20201117114455-6a5ibmr"}
