## 柯里化

* #### 定义

将接受 **n 个参数的 1 个函数改为只接受一个参数的 n 个互相嵌套的函数**，这么说是不是有点拗口，说白了就是本来三个参数，改为嵌套三层，每次只传一个参数，还是先来看下下面的例子吧

* #### 实现方式

这是一个返回省市区的普通函数，接受省，市，区三个参数

```javascript copyable
function getAddress(province,city,area){
  return province + city + area;
}

getAddress('浙江省','杭州市','西湖区');     //浙江省杭州市西湖区
```

现在，我们根据上面的柯里化定义，对它进行改造，成品如下：

```javascript copyable
function getAddress(province){
 return function (city) {
   return function (area) {
     return province + city + area;
   }
 }
}

getAddress('浙江省','杭州市','西湖区');    //浙江省杭州市西湖区
```

上面的方式已经完成了柯里化的改造，正如上面所说的，改造成了**只接受一个参数的 n 个互相嵌套的函数**

* #### 意义

当然，学会了改造只是一部分，最主要要理解一下为什么要这样子改造，比方说我是专门负责杭州市的城区划分的，那么，我们按照前面的第一种方式，在新建城区划分的时候，代码应该是这样子的。

```javascript copyable
getAddress('浙江省','杭州市','西湖区');     //浙江省杭州市西湖区
getAddress('浙江省','杭州市','拱墅区');     //浙江省杭州市拱墅区
getAddress('浙江省','杭州市','上城区');     //浙江省杭州市上城区
```

可以看到，明明浙江省杭州市是固定的，我们每次都要传入三种参数，而且，前面两个参数还是可以随意修改的，我明明只需要管我杭州的事情就可以了，那么，我们进行柯里化改造以后，就可以使用下面的这种方式来进行定义

```javascript copyable
let city = getAddress('浙江省')('杭州市');
city('西湖区');     //浙江省杭州市西湖区
city('拱墅区');     //浙江省杭州市拱墅区
city('上城区');     //浙江省杭州市上城区
```

可以看到，根据 `city()` 来创建的城区，会自动带上 '浙江省杭州市' ，而且，**无权限操作**省市也**不需要操作**省市，这就是**柯里化**的魅力

## 偏函数

* #### 定义

相信大家经过上面的讲解已经大致理解了**柯里化**，那么，偏函数就可以很好理解了，它其实就是 **"随意"** 的柯里化，比方说是有 10 个参数的函数，进行**柯里化**改造以后，就是一个嵌套 10 层的每次只传入 1 个参数的函数，而**偏函数**改造以后，你可以只固定 3 个入参，然后返回一个需要 7 个入参的函数，**偏函数**并不像**柯里化**那样，十分强调**单入参**的概念，它的目标仅仅是把入参分解为两个部分，比起柯里化，它更加地随意一些。

* 实现方式
  还是上面的例子，现在我们对它来进行偏函数改造，实现的项目需要仍然是一样地，我只需要管我杭州的城区划分即可。因为只需要对城区负责，所以，对于省市两个入参可以固定，那么就是一开始两个固定入参，最后再返回一个需要一个入参的函数。可以看到，偏函数相对于柯里化也不光"随意"，更有点根据实际场景，将必要的关联入参固定在一起，更加地和实际使用场景贴合。

  ```javascript copyable
  function getAddress(province,city){
    return function (area) {
      console.log(province + city + area);
    }
  }
  ```

  可以看到，在进行了改造以后，我们将它变成了第一次传入 2 个参数，第二次传入 1 个参数，可以看到，我们并没有刻意地进行**单入参**的改造，这就是**偏函数**

  现在，我们再来继续创建城区划分

  ```javascript copyable
  let city = getAddress('浙江省','杭州市');
  city('西湖区');     //浙江省杭州市西湖区
  city('拱墅区');     //浙江省杭州市拱墅区
  city('上城区');     //浙江省杭州市上城区
  复制代码
  ```

  可以看到，**柯里化**和**偏函数**的动机都是为了让函数"记住"一部分的参数，通过封装的方式，更好地为实际的使用场景服务，而封装的方式，用的都是**闭包**

