# 简单正则一手掌握
{: id="20210223140321-azestu1"}

据我了解正则表达式好像只有前端掌握的不好，这可能跟大部分前端写正则比较少、用到的正则比较简单有关。正则表达式的能力似乎被前端大大低估了。
{: id="20210223140321-rr2ty9b"}

我基本也是用到了正则才会回头看看收藏的文章，写出来自己想要的正则就完事了，对正则的感觉一直是一知半解。凑巧前几天在搞富文本编辑器，用到了一些稍微复杂的正则，这才又回头看了一遍收藏夹。这次的感觉仿佛跟以前不一样了。
{: id="20210223140321-locrw8p"}

## 常用字符
{: id="20210223140321-e49rwrz"}

正则中很多需要强记的字符，这里列出常用的字符和其表达的含义：
{: id="20210223140321-63mb9ez"}

| 常用匹配字符 | 含义                             |
| -------------- | ---------------------------------- |
| [0-9]        | 匹配单个数字0-9                  |
| [a-z]        | 匹配单个小写字母                 |
| [A-Z]        | 匹配单个大写字母                 |
| \s           | 匹配所有空白字符，如空格、换行等 |
| \n           | 匹配所有换行符                   |
| \b           | 匹配边界如字符之间的空格         |
{: id="20210223140321-03f88hn"}

| 特殊字符 | 含义                                                    | 用法                                                            |
| ---------- | --------------------------------------------------------- | ----------------------------------------------------------------- |
| ^        | 1. 匹配输入字符串的开始位置 2. 用在[]中时表示 非        | 1. `/^http/` 匹配以http开头的字符串 2. `/[^a-zA-Z]/` 匹配非字母 |
| $        | 匹配输入字符串的结尾位置                                | `/.com$/` 匹配以。com结尾的字符串                               |
| \|        | 二选一，表示 或                                         | `/a                                                             |
| .        | 小数点匹配换行符\n之外的任何单个字符                    | `/./` 匹配换行符之外的其他字符                                  |
| []       | **中括号匹配一个字符**                                  | `/[aeiou]/` 匹配字母 aeiou 中的一个                             |
| ()       | **小括号表示一个子表达式分组**                          | 匹配的子表达式可以用于以后使用                                  |
| {}       | **大括号表示限定一个表达式多少次**                      | {n} 匹配n次; {n,} 匹配最少n次; {n, m} 匹配n-m次                 |
| +        | 匹配前面的子表达式一次或多次                            | `/[0-9]+/` 匹配一个数字或多个数字                               |
| *        | 匹配前面的子表达式零次或多次                            | `/[0-9]*/` 匹配0次数字或多个数字                                |
| ?        | 1. 匹配前面的子表达式零次或一次 2. 指明一个非贪婪限定符 | 1. `/[0-9]?/` 2. `/<.*?>/` 匹配一个标签如`<p>`                  |
{: id="20210223140321-g62jfst"}

##### 匹配特殊字符本身时需要转义，共有以下几个：
{: id="20210223140321-q4h8dbe"}

```
* . ? + $ ^ [ ] ( ) { } | \ /
复制代码
```
{: id="20210223140321-umr3dcr"}

- {: id="20210223140321-uv0a0qs"}其中 `/` 在字面量中需要转义，在构造函数中不需要，如下匹配一个斜杠 `/`。
  {: id="20210223140321-ef0gbtp"}
{: id="20210223140321-4wfqg9x"}

```js
const reg = /\//
const reg = new RegExp('/')
复制代码
```
{: id="20210223140321-kpoo068"}

- {: id="20210223140321-3lcginz"}在字面量中带一个转义符 `\` 的用构造函数写要带两个转义符 `\\`，如下匹配一个字符串 `.` 。
  {: id="20210223140321-e76gc3f"}
{: id="20210223140321-zg23z6b"}

```js
const reg = /\./
const reg = new RegExp('\\.')
复制代码
```
{: id="20210223140321-p1q4xr6"}

## 常用方法
{: id="20210223140321-bsfk6b1"}

js 中的正则表达式分为字面量和构造函数两种：
{: id="20210223140321-ywxwhu8"}

```js
// 字面量
const reg = /[0-9a-z]/g
// 构造函数
const reg = new RegExp('[0-9a-z]', 'g')
复制代码
```
{: id="20210223140321-qnymdps"}

其中字面量中不能包含变量，构造函数中可以使用变量：
{: id="20210223140321-vzwzwaz"}

```js
const name = '幻灵尔依'
const reg = new RegExp(`我的名字叫${name}`)
复制代码
```
{: id="20210223140321-vazqaut"}

经常会用 `reg.test(str)` 方法来判断字符串中是否匹配到了正则表达式：
{: id="20210223140321-n4bpy25"}

```js
const reg = /[0-9]/
const str = '文本中有没有数字1234等'
if (reg.test(str)) {
  ...
}
复制代码
```
{: id="20210223140321-gtn2os7"}

也经常用`str.replace(reg, '')` 方法来替换字符串中的内容：
{: id="20210223140321-98hx1nk"}

```js
const reg = /[0-9]/g
const str = '文本中的数字1234全部替换成x'
const newStr = str.replace(reg, 'x')
复制代码
```
{: id="20210223140321-2es5203"}

也会用到 `str.match(reg)` 方法来获取匹配到的内容（也可以用`reg.exec(str)`）：
{: id="20210223140321-gv1x1ta"}

```js
const reg = /[0-9]+[.][0-9]+[.][0-9]+/g
const str = '这里有个表名字叫做 11.11.11'
str.match(reg) // ['11.11.11']
复制代码
```
{: id="20210223140321-pxlhfrx"}

- {: id="20210223140321-b5av1ow"}match 中的正则表达式如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。
  {: id="20210223140321-i1x2gm1"}
{: id="20210223140321-vm9a94z"}
- {: id="20210223140321-wn06h9o"}如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性。
  {: id="20210223140321-tbxmhga"}
{: id="20210223140321-hbahfqo"}

> 老子曰：下面才是精华
> {: id="20210223140321-k3hdmh9"}
{: id="20210223140321-upci55p"}

## 贪婪&非贪婪
{: id="20210223140321-i6lyvfu"}

\* 和 + 限定符都是贪婪的，它们会尽可能多的匹配文字。在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。
{: id="20210223140321-8yv0fo7"}

- {: id="20210223140321-4pcuvtt"}贪婪（默认都是贪婪的）
  {: id="20210223140321-tv1wkip"}
{: id="20210223140321-f1n479v"}

```js
const str = '<h1>正则表达式</h1>'
const reg = /<.*>/
str.match(reg) // ['<h1>正则表达式</h1>']
复制代码
```
{: id="20210223140321-vlcue1x"}

- {: id="20210223140321-31kg2ed"}非贪婪
  {: id="20210223140321-dz2whde"}
{: id="20210223140321-85rkngi"}

```js
const str = '<h1>正则表达式</h1>'
const reg = /<.*?>/
str.match(reg) // ['<h1>']
复制代码
```
{: id="20210223140321-0bc3l6x"}

## 捕获分组和回溯引用
{: id="20210223140321-jtsqxv4"}

小括号 `()` 匹配到的子表达式会被缓存为一个个组，方便后面对其引用。假设要获取HTML中的 h1 标签：
{: id="20210223140321-ud57qqk"}

- {: id="20210223140321-ot2maxo"}在正则表达式中使用 \n 可以引用第n个捕获组
  {: id="20210223140321-hgczpij"}
{: id="20210223140321-0em5t3e"}

```js
const str = '<p>正则表达式</p><h1>正则表达式</h1><h2>正则表达式</h2>'
const reg = /<(h1)>.+?<\/\1>/
str.match(reg) // ['<h1>正则表达式</h1>']
复制代码
```
{: id="20210223140321-xh6xg5u"}

- {: id="20210223140321-mmarwm4"}在正则表达式外使用 `$n` 引用第n个捕获组（RegExp.$n）
  {: id="20210223140321-1o8fces"}
{: id="20210223140321-7tqdozh"}

```js
const str = 'abc'
const reg = /(abc)/
RegExp.$1 // 'abc'
str.replace(reg, '$1$1') // 'abcabc'
复制代码
```
{: id="20210223140321-1h8zzpq"}

## 非捕获分组和限定查找
{: id="20210223140321-svll0ot"}

因为捕获组 `()` 会将每个捕获到的结果缓存下来以便引用，所以会造成内存使用增加。如果只是想用分组的原始功能，而不需**要缓存，**{: style="text-shadow: 0px 0px 0.1em, 0px 0px 0.3em;"}则可以使用非捕获分组 `(?:)`
{: id="20210223140321-ocd1azc"}

```js
const str = 'abc'
const reg = /(?:abc)/
RegExp.$1 // ''
复制代码
```
{: id="20210223140321-kvxg3ra"}

非捕获分组还有 `(?=)、(?<=)、(?!)、(?<!) `，他们比 `(?:)` 多了限定作用，即只匹配而不会被输出。
{: id="20210223140321-ah0hmtk"}

### 前向查找
{: id="20210223140321-hja2kmq"}

前向查找是用来限制后缀的。
{: id="20210223140321-868vnnj"}

1. {: id="20210223140321-135fiy3"}`(?=)`： 即查找符合限定条件 `(?=)` 的前面的匹配项（输出内容不包括 `(?=)` 中的匹配项）
   {: id="20210223140321-spconfv"}
{: id="20210223140321-nqegtti"}

```js
const str = 'a.png b.jpg c.gif d.svg'
// 查找所有 边界开头的、 .svg 前面的 小写字母。
const reg = /\b[a-z](?=.svg)/g
str.match(reg) // ['d']
复制代码
```
{: id="20210223140321-cog62zh"}

1. {: id="20210223140321-ge7an4m"}`(?!)`： 即查找 **不符合** 限定条件 `(?!)` 的前面的匹配项（输出内容不包括 `(?!)` 中的匹配项）
   {: id="20210223140321-adbe1fe"}
{: id="20210223140321-hwrhpxd"}

```js
const str = 'a.png b.jpg c.gif d.svg'
// 查找所有边界开头的、 非.svg 前面的、 `.[a-z]{3}` 前面的 小写字母。
const reg = /\b[a-z](?!.svg)(?=\.[a-z]{3})/g
str.match(reg) // ['a', 'b', 'c']
复制代码
```
{: id="20210223140321-owsy1zw"}

### 后向查找
{: id="20210223140321-rvv3lmh"}

后向查找是用来限制前缀的。
{: id="20210223140321-qn25315"}

1. {: id="20210223140321-5gxpprn"}查找符合限定条件 `(?<=)` 的后面的匹配项（输出内容不包括 `(?<=)` 中的匹配项）
   {: id="20210223140321-jmk87j9"}
{: id="20210223140321-6gj11p2"}

```js
const str = '1. 1111； 2. 2222； 3. 3333； 4. 4444。'
//  查找所有 序号 后面的项。
const reg = /(?<=\b[0-9]+\.\s).+?[；。]/g
str.match(reg) // ["1111；", "2222；", "3333；", "4444。"]
复制代码
```
{: id="20210223140321-4syoq15"}

1. {: id="20210223140321-pnkhtov"}查找 **不符合** 限定条件 `(?<!)` 的后面的匹配项（输出内容不包括 `(?<!)` 中的匹配项）
   {: id="20210223140321-y5bkmrg"}
{: id="20210223140321-zersbfm"}

```js
const str = 'a.png b.jpg c.gif d.svg'
// 查找前缀不为 a b c 的后面的项
const reg = /\b(?<![abc]\.)[a-z]{3}/g
str.match(reg) // ['svg']
复制代码
```
{: id="20210223140321-9ore6gm"}

## 来个能吃的栗子
{: id="20210223140321-gdeenom"}

一般稍微复杂的正则都是多种规则同时使用的，下面来几个例子吧：
{: id="20210223140321-9eowcr9"}

### 前向查找和后向查找齐用：
{: id="20210223140321-vt3evwr"}

假设要获取 `<img crossorigin src="https://abcdefg.com" data-img-url="https://test.com">` 中的 `data-img-url` 属性中的链接。可以确定的是链接左边一定是 `data-img-url="` ，右边一定是紧贴着 `"` （非贪婪）。
{: id="20210223140321-oyk9w12"}

```js
const str = '<img crossorigin src="https://abcdefg.com" data-img-url="https://test.com">'
const dataImgUrl = 'data-img-url'
const reg = new RegExp(`(?<=${dataImgUrl}=").+?(?=")`, 'g')
str.match(reg) // ['https://test.com']
复制代码
```
{: id="20210223140321-hsm5yhv"}

### 回溯引用和非贪婪并用
{: id="20210223140321-iv6oora"}

假如我要获取一段HTML中的文本，但是我又不想要加了 `not-show-in-text` 标记的标签中的文本，可以这样：
{: id="20210223140321-75srwro"}

```js
const notShowInText = 'not-show-in-text'
const html = `
  <p>test1</p>
  <p ${notShowInText} style="text-align: center;">
    <b>表 1.4.4 测试表格</b>
  </p>
  <p>test2</p>
`
const reg = new RegExp(`<([a-z][a-z1-6]*?)[^>]+${notShowInText}[\\s\\S]+?</\\1>`, 'g')
const text = html.replace(reg, '').replace(/<[^>]+>/g, '')
复制代码
```
{: id="20210223140321-h295zlv"}

其中最关键的是要匹配到 `not-show-in-text` 所在的整个标签。`([a-z][a-z1-6]*?)` 匹配了一个非贪婪的标签名，`[^>]` 保证了 `<` 到 `>` 是一个半个完整的标签，`</\\1>` 匹配一个闭合的标签， `[\\s\\S]+?` 匹配了标签见可能出现的任意元素且是非贪婪的。
{: id="20210223140321-hx0g4up"}

### replace第二个参数可以是回调函数
{: id="20210223140321-brg3pwe"}

比如，想把 `yyyy-mm-dd` 格式，替换成 `mm/dd/yyyy` 怎么做？
{: id="20210223140321-qt9pzxz"}

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, "$2/$3/$1");
console.log(result); // "06/12/2017"
复制代码
```
{: id="20210223140321-kh8xn2u"}

其中 replace 第二个参数里用`$1、$2、$3`指代相应的分组。等价于如下的形式：
{: id="20210223140321-h7nvuyj"}

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function() {
	return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;
});
console.log(result); // "06/12/2017"
复制代码
```
{: id="20210223140321-7eb5dh8"}

也等价于：
{: id="20210223140321-onjz1ed"}

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
var result = string.replace(regex, function(match, year, month, day) {
	return month + "/" + day + "/" + year;
});
console.log(result); // "06/12/2017"
```
{: id="20210223140321-u8ywm5y"}


{: id="20210107142821-qhu03ku" type="doc"}
